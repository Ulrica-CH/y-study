# pnpm

## 文件系统

### 软连接（符号连接）

一类特殊的文件，其包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用，类似快捷方式（但实际并不是快捷方式）。

**特点：**

- 软链接是保存着某一个文件的路径，本身并没有内容，可以理解为取出存放路径之后，就只是一个空壳
- 因此软链接的文件基本上不占内存，文件是 0 字节大小

### 硬连接

一种指向文件物理数据块的指针。对于硬链接来说，文件在磁盘中的物理数据会被多个文件名引用。

**工作原理：**

1. 默认情况下，用户不能访问磁盘
2. 需要操作系统的文件系统进行交互，通过文件寻址的方式找到真实数据
3. 这就是硬链接

### 复制、硬软链接区别

#### 文件复制

**命令：**

```bash
# Windows
copy foo.js foo_copy.js

# macOS
cp foo.js foo_copy.js
```

**特点：**

- 会生成一份新的、独立的文件（或文件夹），它们在磁盘上有各自的存储空间，互不影响
- 你改动其中一个，另一个不会变

#### 建立硬链接

**命令：**

```bash
# Windows
mklink /H aaa.js bbb.js

# macOS
ln aaa.js bbb.js
```

**说明：**

- `/H` 参数用于指定创建的是一个硬链接（Hard Link），默认情况下，如果不使用 `/H` 参数，mklink 会创建一个符号链接（软链接）
- 对 `aaa.js` 的改变会同时在 `bbb.js` 中生效，其中同步间隔大概在 0.5-1s 左右，这是数据读取并生效的时间

#### 建立软链接

**特点：**

- 文件的显示中可以看出看到左下角有一个斜箭头，这是软链接的标志
- 打开的软链接文件，不是一串地址，是正常文件内容，因为操作系统会帮我们自动解析
- 一旦我们将 `bbb.js` 文件删除，那么 `aaa.js` 文件就打不开了也找不到了（无法读取）


## 如何解决幽灵依赖和嵌套以及相同依赖问题

### 相同依赖问题

**npm 或 Yarn 的问题：**

- 如果有 100 个项目，并且所有项目都有一个相同的依赖包，那么，在硬盘上就需要保存 100 份该相同依赖包的副本

**pnpm 的解决方案：**

- 使用 pnpm，依赖包将被存放在一个统一的位置，因此：
  1. 如果对同一依赖包使用相同的版本，那么磁盘上只有这个依赖包的一份文件
  2. 如果对同一依赖包需要使用不同的版本，则仅有版本之间不同的文件会被存储起来
  3. 项目安装软件包时，其包含的所有文件都会硬链接到此位置，而不会占用额外的硬盘空间
  4. 这样就可以共享相同依赖

### 幽灵依赖和嵌套问题

**解决方案：**

- 项目安装依赖时，pnpm 并不会将这些依赖的完整包复制到每个项目的 `node_modules` 中，而是通过一系列的硬链接和软链接来管理依赖的文件结构
- `node_modules` 文件夹下的 `bar@1.0.0` 软链接到 `.pnpm` 内的硬链接所在处，而该硬链接所在处会链接到真实数据所在，也就是 `.pnpm store` 之后磁盘内的真实数据

**存储机制：**

- 所有下载的包统一存储在全局内容存储（store）中，通常是目录 `.pnpm-store`
- 相当于一个中转站，接受项目的软连接然后通过硬链接去找真实的硬盘中的数据
- pnpm 7.0 之后，统一的存储位置进行了更改：`<pnpm home directory>/store`

**重要的 store 命令：**

- `prune`（修剪）：从 store 中删除当前未被引用的包来释放 store 的空间
- 这样可以保持 pnpm 全局存储的整洁，避免存储过多不必要的数据
- 假设在项目中更新了某个依赖包版本，而旧版本的包已经不再被任何项目引用。这时候就可以运行 `pnpm store prune`，删除这个旧版本的包

