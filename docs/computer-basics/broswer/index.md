# 浏览器架构

## 多进程架构

- 主进程
  - 负责 UI 界面（地址栏、书签栏）、进程管理、网络请求调度、硬件加速接口
- 渲染进程
  - 每个标签页一般一个渲染进程
  - 每个标签页分配一个，负责网页渲染、JS 执行、DOM 构建、事件处理等
- GPU 进程
  - 页面加速绘制、图层合成
  - 3D 图形渲染
  - CSS 动画加速
  - 视频解码
  - WebGL 支持
- 网络进程
  - 统一处理所有网络请求（HTTP、HTTPS、WebSocket）
  - HTTP/HTTPS 请求处理
  - 网络缓存
  - 代理设置
  - 网络安全
  - 每个页面不是有网络线程吗 ?
- 插件进程
  - 早期用于 Flash 插件等，已基本淘汰
- 为什么要用多进程？
  - 稳定性：某个网页崩了不会影响整个浏览器；
  - 安全性：进程隔离，防止恶意网页窃取其他页面的数据；
  - 多核利用：现代 CPU 是多核的 ?，可以同时运行多个页面

## 渲染进程内的线程架构

- 主线程 - JavaScript 执行、DOM 操作、事件处理

  - 主线程是单线程的，需要处理：

    - JavaScript 执行

      - 变量声明、函数调用
      - 事件处理
      - API 调用

    - DOM 操作

      - 元素创建、删除、修改
      - 样式计算
      - 布局计算

    - 事件处理

      - 用户交互事件
      - 网络事件
      - 定时器事件

    - 页面渲染

      - 样式计算
      - 布局计算
      - 绘制

  - 单线程的限制：
    - ❌ 长时间任务会阻塞页面
    - ❌ 复杂计算影响用户体验
    - ❌ 无法充分利用多核 CPU

- 合成线程 Compositor Thread
- 光栅化线程 Raster Thread
- Web Worker

## Web Worker

- Web Worker 是浏览器提供的多线程解决方案
- 允许在后台线程中运行 JavaScript 代码
- Dedicated Worker（专用 Worker）
  - 只能被创建它的页面访问
  - postMessage 通信
- Shared Worker（共享 Worker）
  - 适用于需要跨页面通信的场景
- Service Worker（服务 Worker）
  - 可以拦截网络请求，实现离线缓存
- Worker 中无法使用
  - ❌ DOM API (document, window)
  - ❌ localStorage, sessionStorage
  - ❌ XMLHttpRequest (但可以使用 fetch)
  - ❌ 大部分 Web API

## 关于网络请求

- 渲染进程确实没有独立的网络线程，网络请求是通过主线程发起，然后通过 IPC 通信交给专门的网络进程处理的
- 优点
  - ✅ 安全性：统一的安全控制
  - ✅ 性能：网络处理不阻塞渲染
  - ✅ 稳定性：网络问题不影响页面
  - ✅ 可维护性：职责分离，架构清晰

## IPC 通信

- 不同的进程之间传递数据、协调工作。因为进程之间默认是内存隔离的，不能直接访问彼此的数据，所以需要一套通信机制

| 方式                           | 原理                         | 说明                |
| ------------------------------ | ---------------------------- | ------------------- |
| **管道（Pipe）**               | 类似双向水管，发送/接收数据  | 最常见于 Linux/UNIX |
| **Socket**                     | 网络套接字，本地/远程都可用  | 灵活但相对重        |
| **共享内存（Shared Memory）**  | 共享一块物理内存             | 速度快，但同步复杂  |
| **消息队列**                   | 按队列顺序传递消息           | 支持异步通信        |
| **文件映射**                   | 通过 mmap 等映射一块文件区域 | 少见                |
| **Chromium 自定义的 IPC 框架** | 基于 Mojo 或 Blink IPC       | 内部高效优化        |

## 进程

-程序运行需要内存空间存储变量函数等等,这块内存空间可以理解为进程
image.png

## 消息队列

- 任务没有优先级 先进先出
- 但是消息多列有优先级

- 不同类型的任务可以分属于不同的队列,不同类型任务也可以在一个队列
- 同一个类型的任务必须在同一个队列
- 浏览器必须准备一个微任务队列 优先级最高 promise MutationObserver
- 交互队列 优先级高
- 延时队列 优先级低

## setTimeout 的偏差问题

### 为什么会有偏差？

1. **最小延迟限制**

   - 浏览器对 `setTimeout` 有最小延迟限制（通常 4ms）
   - 即使设置 0ms，实际延迟可能是 4ms 或更长(以前是,但是现在是嵌套层以后才会 4ms)

2. **事件循环机制**

   - `setTimeout` 的回调函数需要等待当前执行栈清空
   - 如果主线程有长时间任务，会延迟执行
   - 微任务（Promise）优先级高于宏任务（setTimeout）

3. **标签页激活状态**

   - 非激活标签页的 `setTimeout` 延迟会被限制（通常最小 1 秒）
   - 这是为了节省电池和 CPU 资源

4. **系统负载**
   - 系统负载高时，定时器可能被延迟执行
   - 操作系统调度器可能影响定时器精度

## 原子钟是什么？

- 原子钟 是目前世界上最精确的计时设备，它利用原子的量子特性来测量时间。
- 原子钟基于一个简单而深刻的物理现象：当原子吸收特定频率的电磁波时，其电子会从一个能级"跳跃"到另一个能级。这个跃迁频率对于每种原子都是固定且极其稳定的。
- 精度对比
  - 传统石英钟：精度约 10^-6（百万分之一）
  - 铷原子钟：精度约 10^-12（万亿分之一）
  - 铯原子钟：精度约 10^-15（千万亿分之一）
  - 这意味着铯原子钟在运行 1 亿年后，误差也不会超过 1 秒！
