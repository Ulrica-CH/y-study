## 基础概念

设计模式是开发中解决问题的经典方案,不是代码,而是一种通用的思路,帮助提示代码的可维护性,可扩展性

## 设计模式分类

- **创建型 create**: 管理实例的创建,增加代码灵活性
- **结构型 structure**: 简化对象之间的复杂关系
- **行为型 behavior**: 简化对象之间的交互和职责分配

### 创建型模式（5 种）

1. **单例模式** - 确保一个类只有一个实例
2. **工厂模式** - 封装对象创建过程
3. **抽象工厂模式** - 创建相关对象族
4. **建造者模式** - 分步骤构建复杂对象
5. **原型模式** - 通过克隆创建对象

### 结构型模式（7 种）

1. **适配器模式** - 让不兼容接口可以一起工作
2. **装饰器模式** - 动态添加功能
3. **代理模式** - 控制对象访问
4. **外观模式** - 简化复杂系统接口
5. **桥接模式** - 分离抽象和实现
6. **组合模式** - 处理树形结构
7. **享元模式** - 共享细粒度对象

### 行为型模式（11 种）

1. **观察者模式** - 一对多依赖关系
2. **模板方法模式** - 算法框架
3. **策略模式** - 条件渲染
4. **职责链模式** - 请求处理
5. **命令模式** - 请求封装
6. **访问者模式** - 数据结构操作
7. **状态模式** - 状态管理
8. **备忘录模式** - 撤销操作
9. **迭代器模式** - 遍历集合
10. **解释器模式** - 解析语法
11. **中介者模式** - 解耦对象关系

## 前端常用设计模式

### 🎯 最常用的设计模式

| 模式             | 使用频率   | 前端应用场景                       |
| ---------------- | ---------- | ---------------------------------- |
| **单例模式**     | ⭐⭐⭐⭐⭐ | 全局状态管理、路由管理、弹窗管理   |
| **观察者模式**   | ⭐⭐⭐⭐⭐ | 事件系统、数据绑定、组件通信       |
| **工厂模式**     | ⭐⭐⭐⭐   | 组件创建、插件系统、UI 组件库      |
| **策略模式**     | ⭐⭐⭐⭐   | 表单验证、支付方式、排序算法       |
| **代理模式**     | ⭐⭐⭐⭐   | 图片懒加载、缓存代理、权限控制     |
| **装饰器模式**   | ⭐⭐⭐     | 高阶组件、中间件、功能增强         |
| **适配器模式**   | ⭐⭐⭐     | API 适配、第三方库集成、兼容性处理 |
| **状态模式**     | ⭐⭐⭐     | 游戏状态、表单状态、工作流         |
| **命令模式**     | ⭐⭐       | 撤销重做、宏命令、快捷键           |
| **模板方法模式** | ⭐⭐       | 算法框架、生命周期钩子             |

### 🚀 前端框架中的设计模式

#### React 中的设计模式

- **组合模式**: JSX 组件树结构
- **观察者模式**: useState、useEffect 响应式更新
- **工厂模式**: React.createElement
- **代理模式**: React.memo、useMemo
- **装饰器模式**: HOC (高阶组件)
- **策略模式**: 条件渲染、路由匹配

#### Vue 中的设计模式

- **观察者模式**: 响应式系统、事件总线
- **代理模式**: Vue 3 Proxy 响应式
- **工厂模式**: Vue.component 注册
- **策略模式**: 指令系统、过滤器
- **装饰器模式**: 混入 (mixin)、插件系统

#### Angular 中的设计模式

- **依赖注入**: 服务管理
- **观察者模式**: RxJS Observable
- **策略模式**: 管道 (Pipe)
- **装饰器模式**: 装饰器语法
- **工厂模式**: 服务工厂

### 💡 实际开发建议

1. **优先使用简单模式**: 单例、观察者、工厂
2. **根据场景选择**: 不要为了用模式而用模式
3. **保持代码简洁**: 过度设计比不设计更糟糕
4. **团队统一**: 在团队中保持设计模式的一致性
