# 应用层

为用户服务，比如网页浏览、收发邮件、文件传输等

## HTTP 版本

### 0.9

- 纯文本，get 请求

### 1.0

- Header，响应状态吗，POST，HEAD 等方法，可以解析图片音乐等

  - 根据 Content-Type 可以支持多种数据格式

  - 开始支持 cache

  - 不足

    - 短连接

      - Connection: keep-alive

### 1.1

- 长链接，缓存，PUT，DELETE，数据分块，断电传输，缓存 cache-contral

  - TCP 连接默认不关闭，可以被多个请求复用，但是请求串行，不用声明 Connection: keep-alive，通过 connection：close 来表示要关闭

  - 管道化：同一个 TCP 连接里，允许多个请求同时发送，增加了并发性

    - 针对每个域名，可以分配 6 个 tcp 通道，这样就可以并行发送请求

    - 但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求

  - Content-length：区分是哪个包

  - 不足

    - 队头阻塞

      - http

        - HTTP 1.1 虽然支持持久连接，但请求是按顺序处理的

      - tcp

        - 如果 TCP 数据流中的某个数据包丢失，后续数据包必须等待重传

    - 无状态的连接，因此每次请求都需要添加重复的字段，降低了带宽的利用率

### 2.0

- 双工模式：服务端也能同时处理多个请求，解决了队头堵塞的问题

- 多路复用

  - 打碎数据为帧，并行处理。让所有的通信都在一个 TCP 连接上完成，真正实现了请求的并发，个连接上面可以有任意多个流（stream），消息分割成一个或多个帧在流里面传输。帧传输过去以后，再进行重组，形成一个完整的请求或响应

- 头部压缩

  - HPACK 算法
  - 维护一份相同的静态字典，包含常见的头部名称，以及常见的头部名称和,维护一份相同的动态字典，可以动态的添加内容,通过静态 Huffman 编码对传输的首部字段进行编码

  - 传输首部字段的时候，例如要传输 method:GET,那我们只需要传输静态字典里面 method:GET 对应的索引值就可以了，一个字节搞定

- 二进制协议

  - 以前都是基于文本

    - 一条 HTTP 响应，划分成了两个帧来传输，并且采用二进制来编码

- https://juejin.cn/post/6844903734670000142?searchId=2025070518153682DD8A28CC344BC1DA68#heading-3

### 3.0

- 基于 UDP 的 QUIC 协议

  - https://juejin.cn/post/7085694620075556901?searchId=20250705183925042907879CFA20C8B5E7#heading-10

## 缓存

### 强制缓存

- Expires

  - 1.0 版本使用的，绝对时间，如果服务器客户端相差时间大，会有误差

- Cache-Control

  - 利用该字段的 max-age 值来进行判断，是一个相对时间

  - 例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值：

    - **no-cache**：需要进行协商缓存，发送请求到服务器确认是否使用缓存。
    - **no-store**：禁止使用缓存，每一次都要重新请求数据。
    - **public**：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。
    - **private**：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。
- Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 Cache-Control 优先级高

### 协商缓存

- 强缓存没有命中，服务器根据 header 中的部分信息来判断是否命中缓存

  - 如果命中，则返回 304 ，告诉浏览器资源未更新，可使用本地的缓存。没有命中会返回新的资源

  - Last-Modify/If-Modify-Since 和 ETag/If-None-Match.

    - Last-Modify：最后修改时间

    - 浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存

    - 问题

      - 短时间内资源发生了改变，Last-Modified 并不会发生变化，比如 1s 变了 100 次

      - 如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 Last-Modified 可不这样认为,因此便有了 ETag

        - 文件指纹

          - Etag/If-None-Match 返回的是一个校验码。ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 If-None-Match 值来判断是否命中缓存

          - 服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304

          - 弱指纹：生成指纹也需要内存时间，所以使用 last-modify+文件长度

### memory cache

- 缓存到内存中

  - JS 文件等

### disk cache

- 资源缓存到磁盘中

  - CSS 文件加载一次就可渲染出来,我们不会频繁读取它,所以它不适合缓存到内存中

## HTTPS

### HTTP 明文传输，不知道是否被篡改

### TTP 协议中没有加密机制,但可以通 过和 SSL(Secure Socket Layer, 安全套接层 )或 TLS(Transport Layer Security, 安全层传输协议)的组合使用,加密 HTTP 的通信内容。属于通信加密，即在整个通信线路中加密

### 对称加密

- 指双方持有相同的密钥进行通信，加密速度快

- DES AES 3DES

- 可被中间人获取，不安全

### 非对称加密

- 一个称为公开密钥(public key)，即公钥，另一个称为私钥(private key)，即私钥。但是它的加密速度相对于对称加密来说很慢

- 解决了客户端到服务端的加密，但是服务端返回数据没法加密

### 双对称加密

- 双方都有一对密钥，但是加密效率太低

### 混合加密

- 先通过非对称加密获取公钥，再根据会话密钥进行加密传输

- 但是中间人可以伪造公钥，还是不安全

### CA 机构证书

- 服务器先给公钥给到 ca 机构进行加密，生成数字证书给到客户端

  - 证书内容包含了持有人的相关信息，服务器的公钥，签署者签名信息（数字签名）等，最重要的是公钥在数字证书中

  - 一个证书中含有三个部分:"证书内容，散列算法，加密密文"，证书内容会被散列算法 hash 计算出 hash 值，然后使用 CA 机构提供的私钥进行 RSA 加密。

- 客户端内置 ca 机构的公钥进行解密获取到服务器的公钥

  - 同时要根据签名来判断是否一致客户端通过 CA 机构提供的公钥对加密密文进行解密获得散列值（数字签名），同时将证书内容使用相同的散列算法进行 Hash 得到另一个散列值，比对两个散列值，如果两者相等则说明证书没问题

- 然后再通过会话密钥进行加密利用服务器的公钥把自己生成的对称加密密钥加密 发给服务端

- 服务端利用密钥解密 获得加密密钥
  最后服务端和客户端通过对称密钥进行加密的 http 通信

## DNS

- 根域名全球 13 台
- 顶级域名 .com .cn
- 第二层域名 zol.com
- 自己域名 api.xy.cn

## DHCP

- 基于 UDP

- 动态分配 ip，ip 使用过期时间的，需要自动重新续约

## Cookie，Session，Token

### Cookie

- 一种浏览器管理状态的一个文件,保持状态

### Session

- 在服务器端保存用户状态，通过 Session ID 识别用户

- 在分布式系统中需要共享 Sessio

### Token

- 后端系统有多台时，由于是客户端访问时直接带着数据，因此无需做共享数据的操作
